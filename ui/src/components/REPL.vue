<template>
  <div class="flex flex-col h-full min-h-0 border-2 border-grey-10 m-2 p-2">

    <div class="flex flex-row">
      <div v-for="step in playbackStepCount">
        <div v-if="playbackStep + 1 === step">
          &#9635;
        </div>
        <div v-else>
          &#9633;
        </div>
      </div>
    </div>

    <div class="grid grid-cols-3 min-h-0">

      <div class="col-span-2 overflow-y-scroll overflow-x-hidden" id="messages" style="-webkit-scrollbar-color: black black">
        <div v-for="line, lineNum in history" class="line">
          <pre :class="{ historySelected: offset == lineNum, historyNotSelected: offset !== lineNum }">{{ line.trimEnd() }}</pre>
        </div>
      </div>

      <div class="flex-1 overflow-y-scroll overflow-x-scroll text-red-400 text-xs" id="server-messages">
        <div v-for="line, lineNum in serverHistory" class="line">
          <pre>{{ line.trimEnd() }}</pre>
        </div>
      </div>

    </div>

    <div class="border-grey-20 border-t-2 p-1 w-full flex-none flex items-center">
      <div class="flex-grow w-full border-2">
        <input
          id="command-input"
          class="w-full bg-black text-white"
          type=text
          @keydown.enter.prevent="gotInput"
          @keydown.arrow-up.prevent="historyUp"
          @keydown.arrow-down.prevent="historyDown"
          @keydown.tab.prevent="requestCompletions"
          v-model="currentInput" />
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, nextTick, reactive } from 'vue';

const currentInput = ref("");
const history = ref([]);
const serverHistory = ref([]);
const connected = ref(false);
const playbackStep = ref(0);
const playbackStepCount = ref(16);

console.log("Starting connection to WebSocket Server");
const norns = new WebSocket("ws://norns.local:5555/",["bus.sp.nanomsg.org"]);

function longestPrefix(words){
  // check border cases size 1 array and empty first word)
  if (!words[0] || words.length ==  1) return words[0] || "";
  let i = 0;
  // while all words have the same character at position i, increment i
  while(words[0][i] && words.every(w => w[i] === words[0][i]))
    i++;

  // prefix is the substring from the beginning to the last successfully checked i
  return words[0].substr(0, i);
}

norns.onmessage = async (event) => {
  console.log("got message", event);
  const data = event.data;

  let m = data.match(/SERVER MESSAGE: (.*)/);
  if (m) {
    let serverMessage = JSON.parse(m[1]);
    console.log("msg: ", serverMessage);
    if (serverMessage.action == "playback_step") {
      playbackStep.value = parseInt(serverMessage.step);
      playbackStepCount.value = Math.ceil(parseFloat(serverMessage.stepCount));
    }
    return;
  }

  m = data.match(/RESPONSE:(.*)/);
  if (m) {
    let serverMessage = JSON.parse(m[1]);
    console.log("msg: ", serverMessage);
    if (serverMessage.action == "live_event" && serverMessage.result !== undefined) {
      // history.value.push(">> [" + serverMessage.result + "]");
      history.value.push(JSON.stringify(serverMessage.result, null, 2));
      await scrollMessagesToBottom();
    } else if (serverMessage.action == "completions"
        && serverMessage.result !== undefined
        && serverMessage.result.length > 0
        && Array.isArray(serverMessage.result)) {
      console.log("completions:", serverMessage.result);

      if(serverMessage.result.length > 1) {
        serverMessage.result.forEach( completion => {
          history.value.push(completion)
        });
      }

      currentInput.value = longestPrefix(serverMessage.result);
      cursorToEnd();

      await scrollMessagesToBottom();
    }
    return;
  }

  // history.value = history.value.slice(1,20)
  const trimmedData = data.trim()
  if (trimmedData) {
    serverHistory.value.push("â†’ [" + trimmedData + "]");
    await scrollServerMessagesToBottom();
  }
};

norns.onopen = (event) => {
  console.log("on open", event)
  console.log("Successfully connected to the echo websocket server...")
  connected.value = true;
};

norns.onclose = () => {
  connected.value = false;
}

async function scrollServerMessagesToBottom() {
  // Scroll to the bottom!
  await nextTick(); // Need the new DOM node to be done
  const element = document.querySelector("#server-messages .line:last-child");
  console.log("scrolling to bottom to", element);
  // element.scrollIntoView({behavior: "smooth", block: "nearest"});
  element.scrollIntoView({block: "nearest"});
}

async function scrollMessagesToBottom() {
  // Scroll to the bottom!
  await nextTick(); // Need the new DOM node to be done
  const element = document.querySelector("#messages .line:last-child");
  console.log("scrolling to bottom to", element);
  // element.scrollIntoView({behavior: "smooth", block: "nearest"});
  if (element) {
    element.scrollIntoView({block: "end"});
  }
}

async function scrollMessagesToSelected() {
  await nextTick(); // Need the new DOM node to be done
  const element = document.querySelector("#messages .line .historySelected");
  console.log("Srolling to", element);
  // element.scrollIntoView({behavior: "smooth", block: "nearest"});
  element.scrollIntoView({ block: 'nearest' }); // {behavior: "smooth", block: "nearest"});
}

function cursorToEnd() {
  const element = document.querySelector("#command-input");
  const len = element.value.length;
  console.log("moving cursor to end", element, len);
  element.focus();
  element.setSelectionRange(len, len);
}


let offset = ref(undefined);

async function historyUp(v) {
  console.log("historyUp", { v });
  if (!offset.value) {
    offset.value = history.value.length - 1;
  } else {
    offset.value = offset.value - 1;
    if (offset.value < 0) {
      offset.value = history.value.length - 1;
    }
  }
  currentInput.value = history.value[offset.value];
  await scrollMessagesToSelected();
  cursorToEnd();
}

async function historyDown(v) {
  console.log("historyDown", { v });
  if (offset.value == undefined) {
    offset.value = 0
  } else {
    offset.value = offset.value + 1;
    if (offset.value >= history.value.length) {
      offset.value = 0;
    }
  }
  currentInput.value = history.value[offset.value];
  await scrollMessagesToSelected();
  cursorToEnd();
}

async function gotInput(v) {
  console.log("gotInput", { v });
  let command = v.target.value;
  if(!command) {
    command = history.value[history.value.length - 1];
  }
  history.value.push(command);
  offset.value = undefined;
  await scrollMessagesToBottom();
  currentInput.value = "";

  console.log("Sending to norns: live_event(" + JSON.stringify(command) + ")\n");
  norns.send("live_event(" + JSON.stringify(command) + ")\n");
  // norns.send(command + "\n");
  // norns.send(command);
}

async function requestCompletions(v) {
  console.log("gotInput", { v });
  const command = v.target.value;

  offset.value = undefined; // Unselect from history

  console.log("Sending to norns: live_event(" + JSON.stringify(command) + ")\n");
  norns.send("completions(" + JSON.stringify(command) + ")\n");
  // norns.send(command + "\n");
  // norns.send(command);
}

</script>

<style>
  .historySelected {
    border: 1px solid white;
}
  .historyNotSelected {
    border: 1px solid black;
}

</style>
